junk

append
-----
Wraps the two given enumerations as a single concatenated enumeration.

```
: seq<'T> -> seq<'T> -> seq<'T>
```

Example
```fsharp

printfn "%A" (Seq.append [| 1; 2; 3|] [ 4; 5; 6])

``` 
Output

```
seq [1; 2; 3; 4; ...] 
```

average
---------
Returns the average of the elements in the sequence.

```
: seq<^T> -> ^T
```

Example
```fsharp

// You can use Seq.average to average elements of a list, array, or sequence. 
let average1 = Seq.average [ 1.0 .. 10.0 ]
printfn "Average: %f" average1
// To average a sequence of integers, use Seq.averageBy to convert to float. 
let average2 = Seq.averageBy (fun elem -> float elem) (seq { 1 .. 10 })
printfn "Average: %f" average2

``` 
Output

```
Average: 5.500000
Average: 5.500000 
```


F# Seq module
-----




append
-----
Wraps the two given enumerations as a single concatenated enumeration.

```
: seq<'T> -> seq<'T> -> seq<'T>
```

Example
```fsharp

printfn "%A" (Seq.append [| 1; 2; 3|] [ 4; 5; 6])

``` 
Output

```
seq [1; 2; 3; 4; ...] 
```

average
---------
Returns the average of the elements in the sequence.

```
: seq<^T> -> ^T
```

Example
```fsharp

// You can use Seq.average to average elements of a list, array, or sequence. 
let average1 = Seq.average [ 1.0 .. 10.0 ]
printfn "Average: %f" average1
// To average a sequence of integers, use Seq.averageBy to convert to float. 
let average2 = Seq.averageBy (fun elem -> float elem) (seq { 1 .. 10 })
printfn "Average: %f" average2

``` 
Output

```
Average: 5.500000
Average: 5.500000 
```

averageBy
---------
Returns the average of the results generated by applying the function to each element of the sequence.

```
: ('T -> ^U) -> seq<'T> -> ^U
```

Example

```fsharp
// You can use Seq.average to average elements of a list, array, or sequence. 
let average1 = Seq.average [ 1.0 .. 10.0 ]
printfn "Average: %f" average1
// To average a sequence of integers, use Seq.averageBy to convert to float. 
let average2 = Seq.averageBy (fun elem -> float elem) (seq { 1 .. 10 })
printfn "Average: %f" average2
``` 
Output

```
Average: 5.500000
Average: 5.500000 
```

cache
------
Returns a sequence that corresponds to a cached version of the input sequence.

```
: seq<'T> -> seq<'T>
```

Example
```fsharp
// Recursive isprime function. 
let isPrime n =
    let rec check i =
        i > n/2 || (n % i <> 0 && check (i + 1))
    check 2

let seqPrimes = seq { for n in 2 .. 10000 do if isPrime n then yield n }
// Cache the sequence to avoid recomputing the sequence elements. 
let cachedSeq = Seq.cache seqPrimes
for index in 1..5 do
    printfn "%d is prime." (Seq.nth (Seq.length cachedSeq - index) cachedSeq)

``` 

Output

```
9973 is prime.
9967 is prime.
9949 is prime.
9941 is prime.
9931 is prime. 
```

cast
-----
Wraps a loosely-typed System.Collections sequence as a typed sequence.

```
: IEnumerable -> seq<'T>
```

Example
```fsharp

open System
let mutable arrayList1 = new System.Collections.ArrayList(10)
for i in 1 .. 10 do arrayList1.Add(10) |> ignore
let seqCast : seq<int> = Seq.cast arrayList1

``` 
Output

```
 open  System
 let   mutable  arrayList1 =  new  System.Collections.ArrayList(10)
 for  i  in  1 .. 10  do  arrayList1.Add(10) |> ignore
 let  seqCast :  seq int > = Seq.cast arrayList1
```

choose
-------
Applies the given function to each element of the list. Return the list comprised of the results for each element where the function returns Some .

```
: ('T -> 'U option) -> seq<'T> -> seq<'U>
```

Example
```fsharp
let numbers = seq {1..20}
let evens = Seq.choose(fun x -> 
                            match x with
                            | x when x%2=0 -> Some(x)
                            | _ -> None ) numbers
printfn "numbers = %A\n" numbers
printfn "evens = %A" evens

``` 
Output

```
numbers = seq [1; 2; 3; 4; ...]

evens = seq [2; 4; 6; 8; ...] 
```

collect
-------

Applies the given function to each element of the sequence and concatenates all the results.

```
: ('T -> 'Collection) -> seq<'T> -> seq<'U>
```

Example
```fsharp

let addNegations seq1 =
   Seq.collect (fun x -> seq { yield x; yield -x }) seq1
   |> Seq.sort
addNegations [ 1 .. 4 ] |> Seq.iter (fun elem -> printf "%d " elem)
printfn ""
addNegations [| 0; -4; 2; -12 |] |> Seq.iter (fun elem -> printf "%d " elem)

``` 
Output

```
-4 -3 -2 -1 1 2 3 4 
-12 -4 -2 0 0 2 4 12 
```

compareWith
------------
Compares two sequences using the given comparison function, element by element.

```
: ('T -> 'T -> int) -> seq<'T> -> seq<'T> -> int
```

Example
```fsharp

let sequence1 = seq { 1 .. 10 }
let sequence2 = seq { 10 .. -1 .. 1 }

// Compare two sequences element by element. 
let compareSequences = Seq.compareWith (fun elem1 elem2 ->
    if elem1 > elem2 then 1
    elif elem1 < elem2 then -1
    else 0) 

let compareResult1 = compareSequences sequence1 sequence2
match compareResult1 with
| 1 -> printfn "Sequence1 is greater than sequence2."
| -1 -> printfn "Sequence1 is less than sequence2."
| 0 -> printfn "Sequence1 is equal to sequence2."
| _ -> failwith("Invalid comparison result.")

``` 
Output

```
Sequence1 is less than sequence2. 
```

concat
-------
Combines the given enumeration-of-enumerations as a single concatenated enumeration.

```
: seq<'Collection> -> seq<'T>
```

Example
```fsharp

// Using Seq.append to append an array to a list. 
let seq1to10 = Seq.append [1; 2; 3] [| 4; 5; 6; 7; 8; 9; 10 |]
// Using Seq.concat to concatenate a list of arrays. 
let seqResult = Seq.concat [ [| 1; 2; 3 |]; [| 4; 5; 6 |]; [|7; 8; 9|] ]
Seq.iter (fun elem -> printf "%d " elem) seq1to10
printfn ""
Seq.iter (fun elem -> printf "%d " elem) seqResult

``` 
Output

```
1 2 3 4 5 6 7 8 9 10 
1 2 3 4 5 6 7 8 9  
```

countBy
---------
Applies a key-generating function to each element of a sequence and return a sequence yielding unique keys and their number of occurrences in the original sequence.

```
: ('T -> 'Key) -> seq<'T> -> seq<'Key * int>
```

Example
```fsharp

let mySeq1 = seq { 1.. 100 }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let seqResult = Seq.countBy (fun elem ->
    if (elem % 2 = 0) then 0 else 1) mySeq1

printSeq seqResult

``` 
Output

(1, 50) (0, 50) 

delay
-------
Returns a sequence that is built from the given delayed specification of a sequence.

```
: (unit -> seq<'T>) -> seq<'T>
```

Example
```fsharp

// Normally sequences are evaluated lazily.  In this case, 
// the sequence is created from a list, which is not evaluated 
// lazily. Therefore, without Seq.delay, the elements would be 
// evaluated at the time of the call to makeSequence. 
let makeSequence function1 maxNumber = Seq.delay (fun () ->
    let rec loop n acc =
        printfn "Evaluating %d." n
        match n with
        | 0 -> acc
        | n -> (function1 n) :: loop (n - 1) acc
    loop maxNumber []
    |> Seq.ofList)
printfn "Calling makeSequence." 
let seqSquares = makeSequence (fun x -> x * x) 4          
let seqCubes = makeSequence (fun x -> x * x * x) 4
printfn "Printing sequences."
printfn "Squares:"
seqSquares |> Seq.iter (fun x -> printf "%d " x)
printfn "\nCubes:"
seqCubes |> Seq.iter (fun x -> printf "%d " x)                       

``` 
Output

```
Calling makeSequence.
Evaluating 4.
Evaluating 3.
Evaluating 2.
Evaluating 1.
Evaluating 0.
Evaluating 4.
Evaluating 3.
Evaluating 2.
Evaluating 1.
Evaluating 0.
Printing sequences.
Squares:
16 9 4 1 
Cubes:
64 27 8 1  
```

distinct
-----------
Returns a sequence that contains no duplicate entries according to generic hash and equality comparisons on the entries. If an element occurs multiple times in the sequence then the later occurrences are discarded.

: seq<'T> -> seq<'T>

Example
```fsharp

let binary n =
    let rec generateBinary n =
        if (n / 2 = 0) then [n]
        else (n % 2) :: generateBinary (n / 2)
    generateBinary n |> List.rev |> Seq.ofList

printfn "%A" (binary 1024)

let resultSequence = Seq.distinct (binary 1024)
printfn "%A" resultSequence

``` 
Output

```
[1; 0; 0; 0; 0; 0; 0; 0; 0; 0; 0]
seq [1; 0] 
```

distinctBy
------------
Returns a sequence that contains no duplicate entries according to the generic hash and equality comparisons on the keys returned by the given key-generating function. If an element occurs multiple times in the sequence then the later occurrences are discarded.

```
: ('T -> 'Key) -> seq<'T> -> seq<'T>
```

Example
```fsharp

let inputSequence = { -5 .. 10 }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn ""
printfn "Original sequence: "
printSeq inputSequence
printfn "\nSequence with distinct absolute values: " 
let seqDistinctAbsoluteValue = Seq.distinctBy (fun elem -> abs elem) inputSequence
seqDistinctAbsoluteValue |> printSeq

``` 
Output

```
Original sequence: 
-5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 

Sequence with distinct absolute values: 
-5 -4 -3 -2 -1 0 6 7 8 9 10  
```

exactlyOne
-----------
Returns the only element of the sequence.

```
: seq<'T> -> 'T
```
Example
```fsharp

``` 
Output

```
// Signature:
exactlyOne : seq  -> 'T
// Usage:
Seq.exactlyOne source
```

exists
-------
Tests if any element of the sequence satisfies the given predicate.

```
: ('T -> bool) -> seq<'T> -> bool
```

Example
```fsharp

// Use Seq.exists to determine whether there is an element of a sequence 
// that satisfies a given Boolean expression. 
// containsNumber returns true if any of the elements of the supplied sequence match  
// the supplied number. 
let containsNumber number seq1 = Seq.exists (fun elem -> elem = number) seq1
let seq0to3 = seq {0 .. 3}
printfn "For sequence %A, contains zero is %b" seq0to3 (containsNumber 0 seq0to3)

``` 
Output

```
For sequence seq [0; 1; 2; 3], contains zero is true 
```

exists2
-------
Tests if any pair of corresponding elements of the input sequences satisfies the given predicate.

```
: ('T1 -> 'T2 -> bool) -> seq<'T1> -> seq<'T2> -> bool
```
Example
```fsharp

// Use Seq.exists2 to compare elements in two sequences. 
// isEqualElement returns true if any elements at the same position in two supplied 
// sequences match. 
let isEqualElement seq1 seq2 = Seq.exists2 (fun elem1 elem2 -> elem1 = elem2) seq1 seq2
let seq1to5 = seq { 1 .. 5 }
let seq5to1 = seq { 5 .. -1 .. 1 }
if (isEqualElement seq1to5 seq5to1) then
    printfn "Sequences %A and %A have at least one equal element at the same position." seq1to5 seq5to1
else
    printfn "Sequences %A and %A do not have any equal elements that are at the same position." seq1to5 seq5to1

``` 
Output

```
Sequences seq [1; 2; 3; 4; ...] and seq [5; 4; 3; 2; ...] have at least one equal element at the same position. 
```

filter
--------
Returns a new collection containing only the elements of the collection for which the given predicate returns true .

```
: ('T -> bool) -> seq<'T> -> seq<'T>
```

Example
```fsharp

let random = new System.Random()
Seq.initInfinite (fun _ -> random.Next())
|> Seq.filter (fun x -> x % 2 = 0)
|> Seq.take 5
|> Seq.iter (fun elem -> printf "%d " elem)
printfn ""

``` 
Output

```
2140052690 963487404 467169526 1800517368 1225141818 
```

find
----
Returns the first element for which the given function returns true .

```
: ('T -> bool) -> seq<'T> -> 'T
```

Example
```fsharp

``` 
Output


findIndex
-----------
Returns the index of the first element for which the given function returns true .

```
: ('T -> bool) -> seq<'T> -> int
```

Example
```fsharp

let seqA = [| 2 .. 100 |]
let delta = 1.0e-10
let isPerfectSquare (x:int) =
    let y = sqrt (float x)
    abs(y - round y) < delta
let isPerfectCube (x:int) =
    let y = System.Math.Pow(float x, 1.0/3.0)
    abs(y - round y) < delta
let element = Seq.find (fun elem -> isPerfectSquare elem && isPerfectCube elem) seqA
let index = Seq.findIndex (fun elem -> isPerfectSquare elem && isPerfectCube elem) seqA
printfn "The first element that is both a square and a cube is %d and its index is %d." element index

``` 
Output

```
The first element that is both a square and a cube is 64 and its index is 62. 
```

fold
------
Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN, then this function computes f (... (f s i0)...) iN .

```
: ('State -> 'T -> 'State) -> 'State -> seq<'T> -> 'State
```

Example
```fsharp

let sumSeq sequence1 = Seq.fold (fun acc elem -> acc + elem) 0 sequence1
Seq.init 10 (fun index -> index * index)
|> sumSeq
|> printfn "The sum of the elements is %d."

``` 
Output

```
The sum of the elements is 285. 
```

forall
--------
Tests if all elements of the sequence satisfy the given predicate.

```
: ('T -> bool) -> seq<'T> -> bool
```

Example
```fsharp

// This function can be used on any sequence, so the same function 
// works with both lists and arrays. 
let allPositive coll = Seq.forall (fun elem -> elem > 0) coll
printfn "%A" (allPositive [| 0; 1; 2; 3 |])
printfn "%A" (allPositive [ 1; 2; 3 ])

``` 
Output

```
false
true 
```

forall2
--------
Tests the all pairs of elements drawn from the two sequences satisfy the given predicate. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.

```
: ('T1 -> 'T2 -> bool) -> seq<'T1> -> seq<'T2> -> bool
```

Example
```fsharp

// This function can be used on any sequence, so the same function 
// works with both lists and arrays. 
let allEqual coll = Seq.forall2 (fun elem1 elem2 -> elem1 = elem2) coll
printfn "%A" (allEqual [| 1; 2 |] [| 1; 2 |])
printfn "%A" (allEqual [ 1; 2 ] [ 2; 1 ])

``` 
Output

```
true
false 
```

groupBy
-------
Applies a key-generating function to each element of a sequence and yields a sequence of unique keys. Each unique key has also contains a sequence of all elements that match to this key.

```
: ('T -> 'Key) -> seq<'T> -> seq<'Key * seq<'T>>
```

Example
```fsharp

let sequence = seq { 1 .. 100 }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let sequences3 = Seq.groupBy (fun index ->
    if (index % 2 = 0) then 0 else 1) sequence
sequences3 |> printSeq

``` 
Output

```
(1, seq [1; 3; 5; 7; ...]) (0, seq [2; 4; 6; 8; ...])  
```

head
----
Returns the first element of the sequence.

```
: seq<'T> -> 'T
```

Example
```fsharp

``` 
Output


init
----
Generates a new sequence which, when iterated, returns successive elements by calling the given function, up to the given count. The results of calling the function are not saved, that is, the function is reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.

```
: int -> (int -> 'T) -> seq<'T>
```

Example
```fsharp

let seqFirst5MultiplesOf10 = Seq.init 5 (fun n -> n * 10)
Seq.iter (fun elem -> printf "%d " elem) seqFirst5MultiplesOf10

``` 
Output

```
0 10 20 30 40 
```

initInfinite
------------
Generates a new sequence which, when iterated, will return successive elements by calling the given function. The results of calling the function are not saved, that is, the function will be reapplied as necessary to regenerate the elements. The function is passed the index of the item being generated.

: (int -> 'T) -> seq<'T>

Example
```fsharp

let seqInfinite = Seq.initInfinite (fun index ->
    let n = float( index + 1 )
    1.0 / (n * n * (if ((index + 1) % 2 = 0) then 1.0 else -1.0)))
printfn "%A" seqInfinite

``` 
Output

```
seq [-1.0; 0.25; -0.1111111111; 0.0625; ...] 
```

isEmpty
--------
Tests whether a sequence has any elements.

```
: seq<'T> -> bool
```

Example
```fsharp

let emptySeq = Seq.empty
let nonEmptySeq = seq { 1 .. 10 }
Seq.isEmpty emptySeq |> printfn "%b"
Seq.isEmpty nonEmptySeq |> printfn "%b"

``` 
Output

```
true
false 
```

iter
------
Applies the given function to each element of the collection.

```
: ('T -> unit) -> seq<'T> -> unit
```

Example
```fsharp

printf "Seq.iter: "
Seq.iter (fun (a,b) -> printf "(%d, %d) " a b) (seq { for i in 1..5 -> (i, i*i) })

``` 
Output

```
-------Enumeration 1------
line System.String[]
line System.String[]
-------Enumeration 2------
line has 8 entries
line has 7 entries
-------Enumeration 3------
lengths of entries: [|7; 0; 6; 0; 6; 5; 0; 1|]
lengths of entries: [|5; 0; 6; 0; 4; 0; 2|] 
```

iteri
------
Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.

: (int -> 'T -> unit) -> seq<'T> -> unit

Example
```fsharp

let seq1 = [1; 2; 3]
let seq2 = [4; 5; 6]
Seq.iter (fun x -> printfn "Seq.iter: element is %d" x) seq1
Seq.iteri(fun i x -> printfn "Seq.iteri: element %d is %d" i x) seq1
Seq.iter2 (fun x y -> printfn "Seq.iter2: elements are %d %d" x y) seq1 seq2

``` 
Output

```
Seq.iter: element is 1
Seq.iter: element is 2
Seq.iter: element is 3
Seq.iteri: element 0 is 1
Seq.iteri: element 1 is 2
Seq.iteri: element 2 is 3
Seq.iter2: elements are 1 4
Seq.iter2: elements are 2 5
Seq.iter2: elements are 3 6 
```

iter2
------
Applies the given function to two collections simultaneously. If one sequence is shorter than the other then the remaining elements of the longer sequence are ignored.

```
: ('T1 -> 'T2 -> unit) -> seq<'T1> -> seq<'T2> -> unit
```

Example
```fsharp

let seq1 = [1; 2; 3]
let seq2 = [4; 5; 6]
Seq.iter (fun x -> printfn "Seq.iter: element is %d" x) seq1
Seq.iteri(fun i x -> printfn "Seq.iteri: element %d is %d" i x) seq1
Seq.iter2 (fun x y -> printfn "Seq.iter2: elements are %d %d" x y) seq1 seq2

``` 
Output

```
Seq.iter: element is 1
Seq.iter: element is 2
Seq.iter: element is 3
Seq.iteri: element 0 is 1
Seq.iteri: element 1 is 2
Seq.iteri: element 2 is 3
Seq.iter2: elements are 1 4
Seq.iter2: elements are 2 5
Seq.iter2: elements are 3 6 
```

last
----
Returns the last element of the sequence.

```
: seq<'T> -> 'T
```
Example
```fsharp

``` 
Output

```
// Signature:
last : seq  -> 'T
// Usage:
Seq.last source
```

length
--------
Returns the length of the sequence.

```
: seq<'T> -> int
```

Example
```fsharp

``` 
Output


map
----
Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The given function will be applied as elements are demanded using the MoveNext method on enumerators retrieved from the object.

```
: ('T -> 'U) -> seq<'T> -> seq<'U>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.map : ('T -> 'U) -> seq  -> seq 

// Usage:
Seq.map mapping source
```

mapi
-----
Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

```
: (int -> 'T -> 'U) -> seq<'T> -> seq<'U>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.mapi : (int -> 'T -> 'U) -> seq  -> seq 

// Usage:
Seq.mapi mapping source
```

map2
-----
Creates a new collection whose elements are the results of applying the given function to the corresponding pairs of elements from the two sequences. If one input sequence is shorter than the other then the remaining elements of the longer sequence are ignored.

```
: ('T1 -> 'T2 -> 'U) -> seq<'T1> -> seq<'T2> -> seq<'U>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.map2 : ('T1 -> 'T2 -> 'U) -> seq  -> seq  -> seq 

// Usage:
Seq.map2 mapping source1 source2
```

max
----
Returns the greatest of all elements of the sequence, compared by using Operators.max .

```
: seq<'T> -> 'T
```

Example
```fsharp

``` 
Output


maxBy
------
Returns the greatest of all elements of the sequence, compared by using Operators.max on the function result.

```
: ('T -> 'U) -> seq<'T> -> 'T
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.maxBy : ('T -> 'U) -> seq  -> 'T (requires comparison)

// Usage:
Seq.maxBy projection source
```

min
----
Returns the lowest of all elements of the sequence, compared by using Operators.min .

```
: seq<'T> -> 'T
```

Example
```fsharp

``` 
Output


minBy
--------
Returns the lowest of all elements of the sequence, compared by using Operators.min on the function result.

```
: ('T -> 'U) -> seq<'T> -> 'T
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.minBy : ('T -> 'U) -> seq  -> 'T (requires comparison)

// Usage:
Seq.minBy projection source
```

nth
-----
Computes the nth element in the collection.

: int -> seq<'T> -> 'T

Example
```fsharp

``` 
Output

```
// Signature:
Seq.nth : int -> seq  -> 'T

// Usage:
Seq.nth index source
```

ofArray
--------
Views the given array as a sequence.

```
: 'T array -> seq<'T>
```

Example
```fsharp

let seq1 = Array.init 10 (fun index -> index.ToString()) 
           |> Seq.ofArray

``` 
Output

```
val seq1 : seq 
```

ofList
-------
Views the given list as a sequence.

```
: 'T list -> seq<'T>
```

Example
```fsharp

let seq1 = List.init 10 (fun index -> index.ToString())
           |> Seq.ofList

``` 
Output

```
val seq1 : seq  = ["0"; "1"; "2"; "3"; "4"; "5"; "6"; "7"; "8"; "9"] 
```

pairwise
---------
Returns a sequence of each element in the input sequence and its predecessor, with the exception of the first element which is only returned as the predecessor of the second element.

```
: seq<'T> -> seq<'T * 'T>
```

Example
```fsharp

let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let seqPairwise = Seq.pairwise (seq { for i in 1 .. 10 -> i*i })
printSeq seqPairwise

printfn "" 
let seqDelta = Seq.map (fun elem -> snd elem - fst elem) seqPairwise
printSeq seqDelta

``` 
Output

```
(1, 4) (4, 9) (9, 16) (16, 25) (25, 36) (36, 49) (49, 64) (64, 81) (81, 100) 

3 5 7 9 11 13 15 17 19 
```

pick
-----
Applies the given function to successive elements, returning the first value where the function returns a Some value.

```
: ('T -> 'U option) -> seq<'T> -> 'U
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.pick : ('T -> 'U option) -> seq  -> 'U

// Usage:
Seq.pick chooser source
```

readonly
-----------
Creates a new sequence object that delegates to the given sequence object. This ensures the original sequence cannot be rediscovered and mutated by a type cast. For example, if given an array the returned sequence will return the elements of the array, but you cannot cast the returned sequence object to an array.

```
: seq<'T> -> seq<'T>
```

Example
```fsharp

type ArrayContainer(start, finish) =
    let internalArray = [| start .. finish |]
    member this.RangeSeq = Seq.readonly internalArray
    member this.RangeArray = internalArray

let newArray = new ArrayContainer(1, 10)
let rangeSeq = newArray.RangeSeq
let rangeArray = newArray.RangeArray
// These lines produce an error:  
//let myArray = rangeSeq :> int array 
//myArray.[0] <- 0 
// The following line does not produce an error.  
// It does not preserve encapsulation.
rangeArray.[0] <- 0

``` 
Output


reduce
-------
Applies a function to each element of the sequence, threading an accumulator argument through the computation. Begin by applying the function to the first two elements. Then feed this result into the function along with the third element and so on. Return the final result.

```
: ('T -> 'T -> 'T) -> seq<'T> -> 'T
```

Example
```fsharp

``` 
Output


```
// Signature:
Seq.reduce : ('T -> 'T -> 'T) -> seq  -> 'T

// Usage:
Seq.reduce reduction source
```

scan
-----
Like Seq.fold , but computes on-demand and returns the sequence of intermediary and final results.

```
: ('State -> 'T -> 'State) -> 'State -> seq<'T> -> seq<'State>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.scan : ('State -> 'T -> 'State) -> 'State -> seq  -> seq 

// Usage:
Seq.scan folder state source
```

singleton
---------
Returns a sequence that yields one item only.

```
: 'T -> seq<'T>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.singleton : 'T -> seq 

// Usage:
Seq.singleton value
```

skip
------
Returns a sequence that skips a specified number of elements of the underlying sequence and then yields the remaining elements of the sequence.

```
: int -> seq<'T> -> seq<'T>
```

Example
```fsharp

let mySeq = seq { for i in 1 .. 10 -> i*i }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let mySeqSkipFirst5 = Seq.skip 5 mySeq
mySeqSkipFirst5 |> printSeq

``` 
Output

```
36 49 64 81 100  
```

skipWhile
-----------
Returns a sequence that, when iterated, skips elements of the underlying sequence while the given predicate returns true , and then yields the remaining elements of the sequence.

```
: ('T -> bool) -> seq<'T> -> seq<'T>
```

Example
```fsharp

let mySeq = seq { for i in 1 .. 10 -> i*i }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let mySeqSkipWhileLessThan10 = Seq.skipWhile (fun elem -> elem < 10) mySeq
mySeqSkipWhileLessThan10 |> printSeq

``` 
Output

```
16 25 36 49 64 81 100  
```

sort
------
Yields a sequence ordered by keys.

: seq<'T> -> seq<'T>

Example
```fsharp

``` 
Output


sum
----
Returns the sum of the elements in the sequence.

```
: seq<^T> -> ^T
```
Example
```fsharp

``` 
Output

```
// Signature:
Seq.sum : seq  -> ^T (requires ^T with static member (+) and ^T with static member Zero)

// Usage:
Seq.sum source
```

sumBy
-------
Returns the sum of the results generated by applying the function to each element of the sequence.

Example
```fsharp

``` 
Output

```
// Signature:
Seq.sumBy : ('T -> ^U) -> seq  -> ^U (requires ^U with static member (+) and ^U with static member Zero)

// Usage:
Seq.sumBy projection source
```

take
------
Returns the first elements of the sequence up to a specified count.

```
: int -> seq<'T> -> seq<'T>
```

Example
```fsharp

let mySeq = seq { for i in 1 .. 10 -> i*i }
let truncatedSeq = Seq.truncate 5 mySeq
let takenSeq = Seq.take 5 mySeq

let truncatedSeq2 = Seq.truncate 20 mySeq
let takenSeq2 = Seq.take 20 mySeq

let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 

// Up to this point, the sequences are not evaluated. 
// The following code causes the sequences to be evaluated.
truncatedSeq |> printSeq
truncatedSeq2 |> printSeq
takenSeq |> printSeq
// The following line produces a run-time error (in printSeq):
takenSeq2 |> printSeq

``` 
Output

```
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
```

takeWhile
-----------
Returns a sequence that, when iterated, yields elements of the underlying sequence while the given predicate returns true , and then returns no further elements.

```
: ('T -> bool) -> seq<'T> -> seq<'T>
```

Example
```fsharp

let mySeq = seq { for i in 1 .. 10 -> i*i }
let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 
let mySeqLessThan10 = Seq.takeWhile (fun elem -> elem < 10) mySeq
mySeqLessThan10 |> printSeq

``` 
Output

```
1 4 9 
```

toArray
--------
Creates an array from the given collection.

```
: seq<'T> -> 'T []
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.toArray : seq  -> 'T array

// Usage:
Seq.toArray source
```

toList
--------
Creates a list from the given collection.

```
: seq<'T> -> 'T list
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.toList : seq  -> 'T list

// Usage:
Seq.toList source
```

tryFind
-------
Returns the first element for which the given function returns true , or None if no such element exists.

```
: ('T -> bool) -> seq<'T> -> 'T option
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.tryFind : ('T -> bool) -> seq  -> 'T option

// Usage:
Seq.tryFind predicate source
```

tryFindIndex
-------------
Returns the index of the first element in the sequence that satisfies the given predicate, or None if no such element exists.

```
: ('T -> bool) -> seq<'T> -> int option
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.tryFindIndex : ('T -> bool) -> seq  -> int option

// Usage:
Seq.tryFindIndex predicate source
```

tryPick
-----------
Applies the given function to successive elements, returning the first value where the function returns a Some value.

```
: ('T -> 'U option) -> seq<'T> -> 'U option
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.tryPick : ('T -> 'U option) -> seq  -> 'U option

// Usage:
Seq.tryPick chooser source
```

truncate
---------
Returns a sequence that when enumerated returns no more than a specified number of elements.

```
: int -> seq<'T> -> seq<'T>
```

Example
```fsharp

let mySeq = seq { for i in 1 .. 10 -> i*i }
let truncatedSeq = Seq.truncate 5 mySeq
let takenSeq = Seq.take 5 mySeq

let truncatedSeq2 = Seq.truncate 20 mySeq
let takenSeq2 = Seq.take 20 mySeq

let printSeq seq1 = Seq.iter (printf "%A ") seq1; printfn "" 

// Up to this point, the sequences are not evaluated. 
// The following code causes the sequences to be evaluated.
truncatedSeq |> printSeq
truncatedSeq2 |> printSeq
takenSeq |> printSeq
// The following line produces a run-time error (in printSeq):
takenSeq2 |> printSeq

``` 
Output

```
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
1 4 9 16 25 
1 4 9 16 25 36 49 64 81 100 
```

unfold
------
Returns a sequence that contains the elements generated by the given computation.

```
: ('State -> 'T * 'State option) -> 'State -> seq<'T>
```

Example
```fsharp

let seq1 = Seq.unfold (fun state -> if (state > 20) then None else Some(state, state + 1)) 0
printfn "The sequence seq1 contains numbers from 0 to 20." 
for x in seq1 do printf "%d " x
let fib = Seq.unfold (fun state ->
    if (snd state > 1000) then None
    else Some(fst state + snd state, (snd state, fst state + snd state))) (1,1)
printfn "\nThe sequence fib contains Fibonacci numbers." 
for x in fib do printf "%d " x

``` 
Output

```
The sequence seq1 contains numbers from 0 to 20.
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 
The sequence fib contains Fibonacci numbers.
2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 
```

where
--------
Returns a new collection containing only the elements of the collection for which the given predicate returns true . A synonym for Seq.filter .

: ('T -> bool) -> seq<'T> -> seq<'T>

Example
```fsharp

``` 
Output

```
// Signature:
where : ('T -> bool) -> seq  -> seq 
// Usage:
Seq.where predicate source
```

windowed
----------
Returns a sequence that yields sliding windows of containing elements drawn from the input sequence. Each window is returned as a fresh array.

```
: int -> seq<'T> -> seq<'T []>
```

Example
```fsharp

let seqNumbers = [ 1.0; 1.5; 2.0; 1.5; 1.0; 1.5 ] :> seq<float>
let seqWindows = Seq.windowed 3 seqNumbers
let seqMovingAverage = Seq.map Array.average seqWindows
printfn "Initial sequence: "
printSeq seqNumbers
printfn "\nWindows of length 3: "
printSeq seqWindows
printfn "\nMoving average: "
printSeq seqMovingAverage

``` 
Output

```
Initial sequence: 
1.0 1.5 2.0 1.5 1.0 1.5 

Windows of length 3: 
[|1.0; 1.5; 2.0|] [|1.5; 2.0; 1.5|] [|2.0; 1.5; 1.0|] [|1.5; 1.0; 1.5|] 

Moving average: 
1.5 1.666666667 1.5 1.333333333  
```

zip
-------
Combines the two sequences into a list of pairs. The two sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.

```
: seq<'T1> -> seq<'T2> -> seq<'T1 * 'T2>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.zip : seq  -> seq  -> seq 

// Usage:
Seq.zip source1 source2
```

zip3
------
Combines the three sequences into a list of triples. The sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequences are ignored.

```
: seq<'T1> -> seq<'T2> -> seq<'T3> -> seq<'T1 * 'T2 * 'T3>
```

Example
```fsharp

``` 
Output

```
// Signature:
Seq.zip3 : seq  -> seq  -> seq  -> seq 

// Usage:
Seq.zip3 source1 source2 source3
```
