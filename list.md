append
----
Returns a new list that contains the elements of the first list followed by elements of the second.

```
: 'T list -> 'T list -> 'T list
```

Example
```fsharp

let list1to10 = List.append [1; 2; 3] [4; 5; 6; 7; 8; 9; 10]
let listResult = List.concat [ [1; 2; 3]; [4; 5; 6]; [7; 8; 9] ]
List.iter (fun elem -> printf "%d " elem) list1to10
printfn ""
List.iter (fun elem -> printf "%d " elem) listResult

```
Output

```
1 2 3 4 5 6 7 8 9 10 
1 2 3 4 5 6 7 8 9 
```

average
---------
Returns the average of the elements in the list.

```
: 'T list -> ^T
```

Example
```fsharp

// Compute the average of the elements of a list by using List.average. 
let avg1 = List.average [0.0; 1.0; 1.0; 2.0]

printfn "%f" avg1

```
Output

```
1.000000 
```

averageBy
-------------
Returns the average of the elements generated by applying the function to each element of the list.

```
: ('T -> ^U) -> 'T list -> ^U
```

Example
```fsharp

let avg2 = List.averageBy (fun elem -> float elem) [1 .. 10]
printfn "%f" avg2

```
Output

```
5.500000 
```

choose
---------
Applies the given function to each element of the list. Returns the list comprised of the results for each element where the function returns Some .

```
: ('T -> 'U option) -> 'T list -> 'U list
```

Example
```fsharp

let listWords = [ "and"; "Rome"; "Bob"; "apple"; "zebra" ]
let isCapitalized (string1:string) = System.Char.IsUpper string1.[0]
let results = List.choose (fun elem ->
    match elem with
    | elem when isCapitalized elem -> Some(elem + "'s")
    | _ -> None) listWords
printfn "%A" results

```
Output

```
["Rome's"; "Bob's"] 
```

collect
--------
For each element of the list, applies the given function. Concatenates all the results and return the combined list.

```
: ('T -> 'U list) -> 'T list -> 'U list
```

Example
```fsharp

let list1 = [10; 20; 30]
let collectList = List.collect (fun x -> [for i in 1..3 -> x * i]) list1
printfn "%A" collectList

```
Output

```
[10; 20; 30; 20; 40; 60; 30; 60; 90] 
```

concat
-------
Returns a new list that contains the elements of each the lists in order.

```
: seq<'T list> -> 'T list
```

Example
```fsharp

let list1to10 = List.append [1; 2; 3] [4; 5; 6; 7; 8; 9; 10]
let listResult = List.concat [ [1; 2; 3]; [4; 5; 6]; [7; 8; 9] ]
List.iter (fun elem -> printf "%d " elem) list1to10
printfn ""
List.iter (fun elem -> printf "%d " elem) listResult

```
Output

```
1 2 3 4 5 6 7 8 9 10 
1 2 3 4 5 6 7 8 9 
```

exists
--------
Tests if any element of the list satisfies the given predicate.

```
: ('T -> bool) -> 'T list -> bool
```

Example
```fsharp

// Use List.exists to determine whether there is an element of a list satisfies a given Boolean expression. 
// containsNumber returns true if any of the elements of the supplied list match  
// the supplied number. 
let containsNumber number list = List.exists (fun elem -> elem = number) list
let list0to3 = [0 .. 3]
printfn "For list %A, contains zero is %b" list0to3 (containsNumber 0 list0to3)

```
Output

```
For list [0; 1; 2; 3], contains zero is true 
```

exists2
----------
Tests if any pair of corresponding elements of the lists satisfies the given predicate.

```
: ('T1 -> 'T2 -> bool) -> 'T1 list -> 'T2 list -> bool
```

Example
```fsharp

// Use List.exists2 to compare elements in two lists. 
// isEqualElement returns true if any elements at the same position in two supplied 
// lists match. 
let isEqualElement list1 list2 = List.exists2 (fun elem1 elem2 -> elem1 = elem2) list1 list2
let list1to5 = [ 1 .. 5 ]
let list5to1 = [ 5 .. -1 .. 1 ]
if (isEqualElement list1to5 list5to1) then
    printfn "Lists %A and %A have at least one equal element at the same position." list1to5 list5to1
else
    printfn "Lists %A and %A do not have an equal element at the same position." list1to5 list5to1

```
Output

```
Lists [1; 2; 3; 4; 5] and [5; 4; 3; 2; 1] have at least one equal element at the same position. 
```

filter
------
Returns a new collection containing only the elements of the collection for which the given predicate returns true .

```
: ('T -> bool) -> 'T list -> 'T list
```

Example
```fsharp

let data = [("Cats",4);
            ("Dogs",5);
            ("Mice",3);
            ("Elephants",2)]
let res = data |> List.filter (fun (nm,x) -> nm.Length <= 4)
printfn "Animals with short names: %A" res

```
Output

```
Animals with short names: [("Cats", 4); ("Dogs", 5); ("Mice", 3)] 
```

find
---------
Returns the first element for which the given function returns true .

: ('T -> bool) -> 'T list -> 'T

Example
```fsharp

```
Output


findIndex
----------
Returns the index of the first element in the list that satisfies the given predicate.

```
: ('T -> bool) -> 'T list -> int
```

Example
```fsharp

let list1 = [ 2 .. 100 ]
let delta = 1.0e-10
let isPerfectSquare (x:int) =
    let y = sqrt (float x)
    abs(y - round y) < delta
let isPerfectCube (x:int) =
    let y = System.Math.Pow(float x, 1.0/3.0)
    abs(y - round y) < delta
let element = List.find (fun elem -> isPerfectSquare elem && isPerfectCube elem) list1
let index = List.findIndex (fun elem -> isPerfectSquare elem && isPerfectCube elem) list1
printfn "The first element that is both a square and a cube is %d and its index is %d." element index

```
Output

```
The first element that is both a square and a cube is 64 and its index is 62. 
```

fold
-------
Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the function to it and the first element of the list. Then, it passes this result into the function along with the second element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN , then this function computes f (... (f s i0) i1 ...) iN .

```
: ('State -> 'T -> 'State) -> 'State -> 'T list -> 'State
```

Example
```fsharp

let sumList list = List.fold (fun acc elem -> acc + elem) 0 list
printfn "Sum of the elements of list %A is %d." [ 1 .. 3 ] (sumList [ 1 .. 3 ])

// The following example computes the average of a list. 
let averageList list = (List.fold (fun acc elem -> acc + float elem) 0.0 list / float list.Length)

// The following example computes the standard deviation of a list. 
// The standard deviation is computed by taking the square root of the 
// sum of the variances, which are the differences between each value 
// and the average. 
let stdDevList list =
    let avg = averageList list
    sqrt (List.fold (fun acc elem -> acc + (float elem - avg) ** 2.0 ) 0.0 list / float list.Length)

let testList listTest =
    printfn "List %A average: %f stddev: %f" listTest (averageList listTest) (stdDevList listTest)

testList [1; 1; 1]
testList [1; 2; 1]
testList [1; 2; 3]

// List.fold is the same as to List.iter when the accumulator is not used. 
let printList list = List.fold (fun acc elem -> printfn "%A" elem) () list
printList [0.0; 1.0; 2.5; 5.1 ]

// The following example uses List.fold to reverse a list. 
// The accumulator starts out as the empty list, and the function uses the cons operator 
// to add each successive element to the head of the accumulator list, resulting in a 
// reversed form of the list. 
let reverseList list = List.fold (fun acc elem -> elem::acc) [] list
printfn "%A" (reverseList [1 .. 10])

```
Output

```
Sum of the elements of list [1; 2; 3] is 6.
List [1; 1; 1] average: 1.000000 stddev: 0.000000
List [1; 2; 1] average: 1.333333 stddev: 0.471405
List [1; 2; 3] average: 2.000000 stddev: 0.816497
0.0
1.0
2.5
5.1
[10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 
```

fold2
---------
Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN , then this function computes f (... (f s i0 j0)...) iN jN .

: ('State -> 'T1 -> 'T2 -> 'State) -> 'State -> 'T1 list -> 'T2 list -> 'State

Example
```fsharp

// Use List.fold2 to perform computations over two lists (of equal size) at the same time. 
// Example: Sum the greater element at each list position. 
let sumGreatest list1 list2 = List.fold2 (fun acc elem1 elem2 ->
                                              acc + max elem1 elem2) 0 list1 list2

let sum = sumGreatest [1; 2; 3] [3; 2; 1]
printfn "The sum of the greater of each pair of elements in the two lists is %d." sum

```
Output

```
The sum of the greater of each pair of elements in the two lists is 8.
```

foldBack
----------
Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN then computes f i0 (...(f iN s)) .

```
: ('T -> 'State -> 'State) -> 'T list -> 'State -> 'State
```
Example
```fsharp

let sumListBack list = List.foldBack (fun acc elem -> acc + elem) list 0
printfn "%d" (sumListBack [1; 2; 3])

// For a calculation in which the order of traversal is important, fold and foldBack have different 
// results. For example, replacing foldBack with fold in the copyList function 
// produces a function that reverses the list, rather than copying it. 
let copyList list = List.foldBack (fun elem acc -> elem::acc) list []
printfn "%A" (copyList [1 .. 10])

```
Output

```
6
[1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 
```
foldBack2
-----------
Applies a function to corresponding elements of two collections, threading an accumulator argument through the computation. The collections must have identical sizes. If the input function is f and the elements are i0...iN and j0...jN , then this function computes f i0 j0 (...(f iN jN s)) .

: ('T1 -> 'T2 -> 'State -> 'State) -> 'T1 list -> 'T2 list -> 'State -> 'State

Example
```fsharp

type Transaction2 =
    | Deposit
    | Withdrawal
    | Interest

let transactionTypes2 = [Deposit; Deposit; Withdrawal; Interest]
let transactionAmounts2 = [100.00; 1000.00; 95.00; 0.05 / 12.0 ]
let initialBalance2 = 200.00

// Because fold2 processes the lists by starting at the head element, 
// the interest is calculated last, on the balance of 1205.00. 
let endingBalance2 = List.fold2 (fun acc elem1 elem2 ->
                                match elem1 with
                                | Deposit -> acc + elem2
                                | Withdrawal -> acc - elem2
                                | Interest -> acc * (1.0 + elem2))
                                initialBalance2
                                transactionTypes2
                                transactionAmounts2
printfn "%f" endingBalance2

```
Output

```
1205.833333 
```
forall
-----------
Tests if all elements of the collection satisfy the given predicate.

```
: ('T -> bool) -> 'T list -> bool
```

Example
```fsharp

let isAllZeroes list = List.forall (fun elem -> elem = 0.0) list
printfn "%b" (isAllZeroes [0.0; 0.0])
printfn "%b" (isAllZeroes [0.0; 1.0])

```
Output

```
true
false 
```

forall2
----------
Tests if all corresponding elements of the collection satisfy the given predicate pairwise.

```
: ('T1 -> 'T2 -> bool) -> 'T1 list -> 'T2 list -> bool
```

Example
```fsharp

let listEqual list1 list2 = List.forall2 (fun elem1 elem2 -> elem1 = elem2) list1 list2
printfn "%b" (listEqual [0; 1; 2] [0; 1; 2])
printfn "%b" (listEqual [0; 0; 0] [0; 1; 0])

```
Output

```
true
false 
```

init
----------
Creates a list by calling the given generator on each index.

```
: int -> (int -> 'T) -> 'T list
```

Example
```fsharp

printfn "List of squares: %A" (List.init 10 (fun index -> index * index))

```
Output

```
List of squares: [0; 1; 4; 9; 16; 25; 36; 49; 64; 81] 
```

isEmpty
----------
Returns true if the list contains no elements, false otherwise.

```
: 'T list -> bool
```

Example
```fsharp

let printList list1 = 
    if (List.isEmpty list1) then
        printfn "There are no elements in this list." 
    else
        printfn "This list contains the following elements:"
        List.iter (fun elem -> printf "%A " elem) list1
        printfn ""
printList [ "test1"; "test2" ]
printList [ ]

```
Output

```
This list contains the following elements:
"test1" "test2" 
There are no elements in this list. 
```

iter
--------
Applies the given function to each element of the collection.

: ('T -> unit) -> 'T list -> unit

Example
```fsharp

let data = ["Cats";"Dogs";"Mice";"Elephants"]
data |> List.iter (fun x -> printfn "item: %s" x)

```
Output

```
item: Cats
item: Dogs
item: Mice
item: Elephants 
```

iter2
----------
Applies the given function to two collections simultaneously. The collections must have identical size.

```
: ('T1 -> 'T2 -> unit) -> 'T1 list -> 'T2 list -> unit
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = [4; 5; 6]
List.iter (fun x -> printfn "List.iter: element is %d" x) list1
List.iteri(fun i x -> printfn "List.iteri: element %d is %d" i x) list1
List.iter2 (fun x y -> printfn "List.iter2: elements are %d %d" x y) list1 list2
List.iteri2 (fun i x y ->
               printfn "List.iteri2: element %d of list1 is %d element %d of list2 is %d"
                 i x i y)
            list1 list2

```
Output

```
List.iter: element is 1
List.iter: element is 2
List.iter: element is 3
List.iteri: element 0 is 1
List.iteri: element 1 is 2
List.iteri: element 2 is 3
List.iter2: elements are 1 4
List.iter2: elements are 2 5
List.iter2: elements are 3 6
List.iteri2: element 0 of list1 is 1 element 0 of list2 is 4
List.iteri2: element 1 of list1 is 2 element 1 of list2 is 5
List.iteri2: element 2 of list1 is 3 element 2 of list2 is 6 
```

iteri
-------
Applies the given function to each element of the collection. The integer passed to the function indicates the index of element.

```
: (int -> 'T -> unit) -> 'T list -> unit
```

Example
```fsharp

let data = ["Cats";"Dogs";"Mice";"Elephants"]
data |> List.iteri (fun i x -> printfn "item %d: %s" i x)

```
Output

```
item 0: Cats
item 1: Dogs
item 2: Mice
item 3: Elephants 
```

iteri2
-------
Applies the given function to two collections simultaneously. The collections must have identical size. The integer passed to the function indicates the index of element.

```
: (int -> 'T1 -> 'T2 -> unit) -> 'T1 list -> 'T2 list -> unit
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = [4; 5; 6]
List.iter (fun x -> printfn "List.iter: element is %d" x) list1
List.iteri(fun i x -> printfn "List.iteri: element %d is %d" i x) list1
List.iter2 (fun x y -> printfn "List.iter2: elements are %d %d" x y) list1 list2
List.iteri2 (fun i x y ->
               printfn "List.iteri2: element %d of list1 is %d element %d of list2 is %d"
                 i x i y)
            list1 list2

```

Output

```
List.iter: element is 1
List.iter: element is 2
List.iter: element is 3
List.iteri: element 0 is 1
List.iteri: element 1 is 2
List.iteri: element 2 is 3
List.iter2: elements are 1 4
List.iter2: elements are 2 5
List.iter2: elements are 3 6
List.iteri2: element 0 of list1 is 1 element 0 of list2 is 4
List.iteri2: element 1 of list1 is 2 element 1 of list2 is 5
List.iteri2: element 2 of list1 is 3 element 2 of list2 is 6 
```

length
-----------
Returns the length of the list.

```
: 'T list -> int
```

Example
```fsharp

```
Output


map
--------
Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection.

```
: ('T -> 'U) -> 'T list -> 'U list
```

Example
```fsharp

let data = [(1,1,2001); (2,2,2004); (6,17,2009)]
let list1 =
    data |> List.map (fun (a,b,c) -> 
        let date = new System.DateTime(c, a, b)
        date.ToString("F"))

for i in list1 do printfn "%A" i

```
Output

```
"Monday, January 01, 2001 12:00:00 AM"
"Monday, February 02, 2004 12:00:00 AM"
"Wednesday, June 17, 2009 12:00:00 AM" 
```

map2
-------
Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the two collections pairwise.

```
: ('T1 -> 'T2 -> 'U) -> 'T1 list -> 'T2 list -> 'U list
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = [4; 5; 6]
let sumList = List.map2 (fun x y -> x + y) list1 list2
printfn "%A" sumList

```
Output

```
[5; 7; 9] 
```

map3
------
Creates a new collection whose elements are the results of applying the given function to the corresponding elements of the three collections simultaneously.

```
: ('T1 -> 'T2 -> 'T3 -> 'U) -> 'T1 list -> 'T2 list -> 'T3 list -> 'U list
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = [4; 5; 6]
let newList = List.map3 (fun x y z -> x + y + z) list1 list2 [2; 3; 4]
printfn "%A" newList

```
Output

```
[7; 10; 13] 
```

mapi
------
Creates a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

```
: (int -> 'T -> 'U) -> 'T list -> 'U list
```

Example
```fsharp

let list1 = [1; 2; 3]
let newList = List.mapi (fun i x -> (i, x)) list1
printfn "%A" newList

```
Output

```
[(0, 1); (1, 2); (2, 3)] 
```

mapi2
------
Like List.mapi , but mapping corresponding elements from two lists of equal length.

```
: (int -> 'T1 -> 'T2 -> 'U) -> 'T1 list -> 'T2 list -> 'U list
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = [4; 5; 6]
let listAddTimesIndex = List.mapi2 (fun i x y -> (x + y) * i) list1 list2
printfn "%A" listAddTimesIndex

```
Output

```
[0; 7; 18] 
```

max
------
Return the greatest of all elements of the list, compared by using Operators.max .

```
: 'T list -> 'T
```

Example
```fsharp

```
Output


maxBy
------
Returns the greatest of all elements of the list, compared by using Operators.max on the function result.

```
: ('T -> 'U) -> 'T list -> 'T
```

Example
```fsharp

[ -10.0 .. 10.0 ]
|> List.maxBy (fun x -> 1.0 - x * x)
|> printfn "%A"

```
Output

```
0.0
```


min
----
Returns the lowest of all elements of the list, compared by using Operators.min .

```
: 'T list -> 'T
```

Example
```fsharp

```
Output


minBy
--------
Returns the lowest of all elements of the list, compared by using Operators.min on the function result

```
: ('T -> 'U) -> 'T list -> 'T
```

Example
```fsharp

[ -10.0 .. 10.0 ]
|> List.minBy (fun x -> x * x - 1.0)
|> printfn "%A"

```
Output

```
0.0 
```

ofArray
--------
Creates a list from the given array.

```
: 'T [] -> 'T list
```

Example
```fsharp

let list1 = List.ofArray [| 1 .. 10 |]

```
Output

```
val list1 : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 
```

ofSeq
--------
Creates a new list from the given enumerable object.

```
: seq<'T> -> 'T list
```

Example
```fsharp

let list1 = List.ofSeq ( seq { 1 .. 10 } )

```
Output

```
val list1 : int list = [1; 2; 3; 4; 5; 6; 7; 8; 9; 10] 
```

partition
---------
Splits the collection into two collections, containing the elements for which the given predicate returns true and false respectively.

```
: ('T -> bool) -> 'T list * 'T list
```

Example
```fsharp

let list1 = [ 1 .. 10 ]
let listEven, listOdd = List.partition (fun elem -> elem % 2 = 0) list1
printfn "Evens: %A\nOdds: %A" listEven listOdd

```
Output

```
Evens: [2; 4; 6; 8; 10]
Odds: [1; 3; 5; 7; 9] 
```

permute
--------
Returns a list with all elements permuted according to the specified permutation.

```
: (int -> int) -> 'T list -> 'T list
```

Example
```fsharp

let printPermutation n list1 =
    let length = List.length list1
    if (n > 0 && n < length) then
        List.permute (fun index -> (index + n) % length) list1
    else
        list1
    |> printfn "%A" 
let list1 = [ 1 .. 5 ]
// There are 5 valid permutations of list1, with n from 0 to 4. 
for n in 0 .. 4 do
    printPermutation n list1

```
Output

```
[1; 2; 3; 4; 5]
[5; 1; 2; 3; 4]
[4; 5; 1; 2; 3]
[3; 4; 5; 1; 2]
[2; 3; 4; 5; 1] 
```

pick
--------
Applies the given function to successive elements, returning the first result where function returns Some for some value.

```
: ('T -> 'U option) -> 'T list -> 'U
```

Example
```fsharp

let valuesList = [ ("a", 1); ("b", 2); ("c", 3) ]

let resultPick = List.pick (fun elem ->
                    match elem with
                    | (value, 2) -> Some value
                    | _ -> None) valuesList
printfn "%A" resultPick

```
Output

```
\"b\" 
```

reduce
--------
Applies a function to each element of the collection, threading an accumulator argument through the computation. This function applies the specified function to the first two elements of the list. It then passes this result into the function along with the third element, and so on. Finally, it returns the final result. If the input function is f and the elements are i0...iN , then this function computes f (... (f i0 i1) i2 ...) iN .

```
: ('T -> 'T -> 'T) -> 'T list -> 'T
```

Example

```fsharp

let sumAList list =
    try
        List.reduce (fun acc elem -> acc + elem) list
    with
       | :? System.ArgumentException as exc -> 0

let resultSum = sumAList [2; 4; 10]
printfn "%d " resultSum

```
Output

```
16 
```

reduceBack
----------
Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0...iN , then this function computes f i0 (...(f iN-1 iN)) .

```
: ('T -> 'T -> 'T) -> 'T list -> 'T
```

Example
```fsharp

```
Output

```
// Signature:
List.reduceBack : ('T -> 'T -> 'T) -> 'T list -> 'T

// Usage:
List.reduceBack reduction list
```

replicate
------------
Creates a list by calling the given generator on each index.

```
: (int -> 'T -> 'T list)
```

Example
```fsharp

let testList = List.replicate 4 "test"
printfn "%A" testList

```

Output
```
["test"; "test"; "test"; "test"] 
```

rev
-------
Returns a new list with the elements in reverse order.

```
: 'T list -> 'T list
```

Example
```fsharp

let reverseList = List.rev [ 1 .. 10 ]
printfn "%A" reverseList

```
Output

```
[10; 9; 8; 7; 6; 5; 4; 3; 2; 1] 
```

scan
------
Applies a function to each element of the collection, threading an accumulator argument through the computation. This function takes the second argument, and applies the specified function to it and the first element of the list. Then, it passes this result into the function along with the second element and so on. Finally, it returns the list of intermediate results and the final result.

```
: ('State -> 'T -> 'State) -> 'State -> 'T list -> 'State list
```

Example
```fsharp

let initialBalance = 1122.73
let transactions = [ -100.00; +450.34; -62.34; -127.00; -13.50; -12.92 ]
let balances =
    List.scan (fun balance transactionAmount -> balance + transactionAmount)
              initialBalance transactions
printfn "Initial balance:\n $%10.2f" initialBalance
printfn "Transaction   Balance" 
for i in 0 .. List.length transactions - 1 do
    printfn "$%10.2f $%10.2f" transactions.[i] balances.[i]
printfn "Final balance:\n $%10.2f" balances.[ List.length balances - 1]

```
Output

```
Initial balance:
 $   1122.73
Transaction   Balance
$   -100.00 $   1122.73
$    450.34 $   1022.73
$    -62.34 $   1473.07
$   -127.00 $   1410.73
$    -13.50 $   1283.73
$    -12.92 $   1270.23
Final balance:
 $   1257.31 
```

scanBack
------------
Like foldBack , but returns both the intermediate and final results

```
: ('T -> 'State -> 'State) -> 'T list -> 'State -> 'State list
```

Example
```fsharp

// A list of functions that transform  
// integers. (int -> int) 
let ops1 =
 [ (fun x -> x + 1), "add 1"
   (fun x -> x + 2), "add 2"
   (fun x -> x - 5), "subtract 5" ]

let ops2 =
 [ (fun x -> x + 1), "add 1"
   (fun x -> x * 5), "multiply by 5"
   (fun x -> x * x), "square" ]

// Compare scan and scanBack, which apply the 
// operations in the opposite order. 
let compareOpOrder ops x0 =
    let ops, opNames = List.unzip ops
    let xs1 = List.scan (fun x op -> op x) x0 ops
    let xs2 = List.scanBack (fun op x -> op x) ops x0

    printfn "Operations:"
    opNames |> List.iter (fun opName -> printf "%s  " opName)
    printfn "" 

    // Print the intermediate results. 
    let xs = List.zip xs1 (List.rev xs2)
    printfn "List.scan List.scanBack" 
    for (x1, x2) in xs do
        printfn "%10d %10d" x1 x2
    printfn ""

compareOpOrder ops1 10
compareOpOrder ops2 10

```
Output

```
Operations:
add 1  add 2  subtract 5  
List.scan List.scanBack
        10         10
        11          5
        13          7
         8          8

Operations:
add 1  multiply by 5  square  
List.scan List.scanBack
        10         10
        11        100
        55        500
      3025        501 

```

sort
----------
Sorts the given list using Operators.compare .

```
: 'T list -> 'T list
```

Example
```fsharp

```
Output


sortBy
----------
Sorts the given list using keys given by the given projection. Keys are compared using Operators.compare .

```
: ('T -> 'Key) -> 'T list -> 'T list
```

Example
```fsharp

let sortedList2 = List.sortBy (fun elem -> abs elem) [1; 4; 8; -2; 5]
printfn "%A" sortedList2

```
Output

```
[1; -2; 4; 5; 8] 
```

sortWith
----------
Sorts the given list using the given comparison function.

```
: ('T -> 'T -> int) -> 'T list -> 'T list
```

Example
```fsharp

open System

let list1 = [ "<>"; "&"; "&&"; "&&&"; "<"; ">"; "|"; "||"; "|||" ]
printfn "Before sorting: "
list1 |> printfn "%A" 
let sortFunction (string1:string) (string2:string) =
    if (string1.Length > string2.Length) then
       1
    else if (string1.Length < string2.Length) then
       -1
    else
        String.Compare(string1, string2)
List.sortWith sortFunction list1
|> printfn "After sorting:\n%A"

```
Output


sumBy
--------
Returns the sum of the results generated by applying the function to each element of the list.

```
: ('T -> ^U) -> 'T list -> ^U
```

Example
```fsharp

// Compute the sum of the first 10 integers by using List.sum. 
let sum1 = List.sum [1 .. 10]

// Compute the sum of the squares of the elements of a list by using List.sumBy. 
let sum2 = List.sumBy (fun elem -> elem*elem) [1 .. 10]

// Compute the average of the elements of a list by using List.average. 
let avg1 = List.average [0.0; 1.0; 1.0; 2.0]

printfn "%f" avg1

```
Output

```
1.000000 
```

tail
---------
Returns the input list without the first element.

```
: 'T list -> 'T list
```

Example
```fsharp

let list1 = [1; 2; 3]
let list2 = []
// The following line prints [2; 3].
printfn "%A" (List.tail list1)
// The following line throws System.ArgumentException.
printfn "%A" (List.tail list2)

```
Output

```
[2; 3]
System.ArgumentException: The input list was empty. 
```

toArray
---------
Creates an array from the given list.

```
: 'T list -> 'T []
```

Example
```fsharp

let array1 = [ 1; 3; -2; 4 ]
             |> List.toArray
Array.set array1 3 -10
Array.sortInPlaceWith (fun elem1 elem2 -> compare elem1 elem2) array1
printfn "%A" array1

```
Output

```
[|-10; -2; 1; 3|] 
```

toSeq
-----------
Views the given list as a sequence.

```
: 'T list -> seq<'T>
```

Example
```fsharp

 2 3 4 5

```
Output

```
1 2 3 4 5 
```

tryFind
-----------
Returns the first element for which the given function returns true . Return None if no such element exists.

```
: ('T -> bool) -> 'T list -> 'T option
```

Example
```fsharp

let list1d = [1; 3; 7; 9; 11; 13; 15; 19; 22; 29; 36]
let isEven x = x % 2 = 0
match List.tryFind isEven list1d with
| Some value -> printfn "The first even value is %d." value
| None -> printfn "There is no even value in the list." 

match List.tryFindIndex isEven list1d with
| Some value -> printfn "The first even value is at position %d." value
| None -> printfn "There is no even value in the list."

```
Output

```
The first even value is 22.
The first even value is at position 8. 
```

tryFindIndex
----------------
Returns the index of the first element in the list that satisfies the given predicate. Return None if no such element exists.

```
: ('T -> bool) -> 'T list -> int option
```

Example
```fsharp

let list1d = [1; 3; 7; 9; 11; 13; 15; 19; 22; 29; 36]
let isEven x = x % 2 = 0
match List.tryFind isEven list1d with
| Some value -> printfn "The first even value is %d." value
| None -> printfn "There is no even value in the list." 

match List.tryFindIndex isEven list1d with
| Some value -> printfn "The first even value is at position %d." value
| None -> printfn "There is no even value in the list."

```
Output

```
The first even value is 22.
The first even value is at position 8. 
```

tryPick
------------
Applies the given function to successive elements, returning the first result where function returns Some for some value. If no such element exists then return None .

```
: ('T -> 'U option) -> 'T list -> 'U option
```

Example
```fsharp

let findPerfectSquareAndCube list1 =
    let delta = 1.0e-10
    let isPerfectSquare (x:int) =
        let y = sqrt (float x)
        abs(y - round y) < delta
    let isPerfectCube (x:int) =
        let y = System.Math.Pow(float x, 1.0/3.0)
        abs(y - round y) < delta
    // intFunction : (float -> float) -> int -> int 
    // Allows the use of a floating point function with integers. 
    let intFunction function1 number = int (round (function1 (float number)))
    let cubeRoot x = System.Math.Pow(x, 1.0/3.0)
    // testElement: int -> (int * int * int) option 
    // Test an element to see whether it is a perfect square and a perfect 
    // cube, and, if so, return the element, square root, and cube root 
    // as an option value. Otherwise, return None. 
    let testElement elem = 
        if isPerfectSquare elem && isPerfectCube elem then
            Some(elem, intFunction sqrt elem, intFunction cubeRoot elem)
        else None
    match List.tryPick testElement list1 with
    | Some (n, sqrt, cuberoot) ->
        printfn "Found an element %d with square root %d and cube root %d." n sqrt cuberoot
    | None ->
        printfn "Did not find an element that is both a perfect square and a perfect cube."

findPerfectSquareAndCube [ 1 .. 10 ]
findPerfectSquareAndCube [ 2 .. 100 ]
findPerfectSquareAndCube [ 100 .. 1000 ]
findPerfectSquareAndCube [ 1000 .. 10000 ]
findPerfectSquareAndCube [ 2 .. 50 ]

```
Output

```
Found an element 1 with square root 1 and cube root 1.
Found an element 64 with square root 8 and cube root 4.
Found an element 729 with square root 27 and cube root 9.
Found an element 4096 with square root 64 and cube root 16.
Did not find an element that is both a perfect square and a perfect cube. 
```

unzip
-----------
Splits a list of pairs into two lists.

```
: ('T1 * 'T2) list -> 'T1 list * 'T2 list
```

Example
```fsharp

let listA, listB = List.unzip [(1,2); (3,4)]
printfn "%A" listA
printfn "%A" listB

```
Output

```
[1; 3]
[2; 4] 
```

unzip3
--------
Splits a list of triples into three lists.

```
: ('T1 * 'T2 * 'T3) list -> 'T1 list * 'T2 list * 'T3 list
```

Example
```fsharp

let listA, listB, listC = List.unzip3 [(1,2,3); (4,5,6)]
printfn "%A %A %A" listA listB listC

```
Output

```
[1; 4] [2; 5] [3; 6] 
```

zip
---------
Combines the two lists into a list of pairs. The two lists must have equal lengths.

```
: 'T1 list -> 'T2 list -> ('T1 * 'T2) list
```

Example
```fsharp

let listA, listB = List.unzip [(1,2); (3,4)]
printfn "%A" listA
printfn "%A" listB

```
Output

```
[1; 3]
[2; 4] 
```

zip3
----------
Combines the three lists into a list of triples. The lists must have equal lengths.

```
: 'T1 list -> 'T2 list -> 'T3 list -> ('T1 * 'T2 * 'T3) list
```

Example
```fsharp

let listA, listB, listC = List.unzip3 [(1,2,3); (4,5,6)]
printfn "%A %A %A" listA listB listC

```
Output

```
[1; 4] [2; 5] [3; 6] 
```

